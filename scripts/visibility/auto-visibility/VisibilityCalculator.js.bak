/**
 * VisibilityCalculator - Zero-delay visibility calculation
 * Bypasses all throttling and circuit breaking for immediate processing
 */

import { MODULE_ID } from '../../constants.js';
import { getLogger } from '../../utils/logger.js';
import { SpatialAnalysisService } from './core/SpatialAnalysisService.js';
const log = getLogger('VisibilityCalculator');

export class VisibilityCalculator {
  /** @type {VisibilityCalculator} */
  static #instance = null;

  /** @type {LightingCalculator} */
  #lightingCalculator;

  /** @type {VisionAnalyzer} */
  #visionAnalyzer;

  /** @type {ConditionManager} */
  #conditionManager;

  /** @type {SpatialAnalysisService} */
  #spatialAnalyzer;

  /** @type {ExclusionManager} */
  #exclusionManager;

  /** @type {import('./core/LightingRasterService.js').LightingRasterService|null} */
  #lightingRasterService = null;

  constructor() {
    if (VisibilityCalculator.#instance) {
      return VisibilityCalculator.#instance;
    }
    VisibilityCalculator.#instance = this;
  }

  /**
   * Get the singleton instance
   * @returns {VisibilityCalculator}
   */
  static getInstance() {
    if (!VisibilityCalculator.#instance) {
      VisibilityCalculator.#instance = new VisibilityCalculator();
    }
    return VisibilityCalculator.#instance;
  }

  /**
   * Initialize with required components
   * @param {LightingCalculator} lightingCalculator
   * @param {VisionAnalyzer} visionAnalyzer
   * @param {ConditionManager} ConditionManager
   * @param {SpatialAnalysisService} spatialAnalyzer - Optional spatial analysis service for optimizations
   * @param {ExclusionManager} exclusionManager - Optional exclusion manager for token exclusions
   */
  initialize(lightingCalculator, visionAnalyzer, ConditionManager, spatialAnalyzer = null, exclusionManager = null, lightingRasterService = null) {
    this.#lightingCalculator = lightingCalculator;
    this.#visionAnalyzer = visionAnalyzer;
    this.#conditionManager = ConditionManager;
    this.#spatialAnalyzer = spatialAnalyzer;
    this.#exclusionManager = exclusionManager;
    this.#lightingRasterService = lightingRasterService || null;
  }

  /**
   * Calculate visibility between observer and target tokens - IMMEDIATE, NO THROTTLING
   * @param {Token} observer
   * @param {Token} target
   * @returns {Promise<string>} Visibility state
   */
  async calculateVisibility(observer, target, options = undefined) {
    console.log(`🔥 calculateVisibility: ${observer?.name} -> ${target?.name}`);

    // Check if we should skip this calculation based on spatial/LOS optimizations
    const shouldSkip = this._shouldSkipCalculation(observer, target);
    console.log(`🔥 _shouldSkipCalculation returned: ${shouldSkip}`);

    if (shouldSkip) {
      console.log('🔥 SKIPPING CALCULATION - returning observed (THIS IS THE BUG!)');
      return 'observed'; // Default fallback
    }

    console.log('🔥 Proceeding to calculateVisibilityBetweenTokens');
    const result = await this.calculateVisibilityBetweenTokens(observer, target, null, null, options);
    return result;
  }

  /**
   * Calculate visibility between observer and target tokens, IGNORING AVS override flags.
   * This is used for override validation to get the "true" AVS-calculated state.
   * @param {Token} observer
   * @param {Token} target
   * @returns {Promise<string>} Visibility state
   */
  async calculateVisibilityWithoutOverrides(observer, target, options = undefined) {
    if (!observer?.actor || !target?.actor) {
      return 'observed';
    }

    // Temporarily remove any AVS override flag for this observer-target pair
    const targetFlags = target?.document?.flags?.['pf2e-visioner'] || {};
    const observerFlagKey = `avs-override-from-${observer?.document?.id}`;
    let removedOverride = null;
    if (targetFlags[observerFlagKey]) {
      removedOverride = targetFlags[observerFlagKey];
      // Remove override
      delete target.document.flags['pf2e-visioner'][observerFlagKey];
    }
    let result;
    try {
      // Use raw LoS to bypass detection wrappers for the override-free calculation
      result = await this.calculateVisibilityBetweenTokens(observer, target, null, null, options);
    } finally {
      // Restore override if it was present
      if (removedOverride) {
        target.document.flags['pf2e-visioner'][observerFlagKey] = removedOverride;
      }
    }

    return result;
  }

  /**
   * Calculate visibility between observer and target tokens with optional position overrides - IMMEDIATE, NO THROTTLING
   * @param {Token} observer - The observing token
   * @param {Token} target - The target token
   * @param {Object} observerPositionOverride - Optional {x, y} position override for observer (reserved for future use)
   * @param {Object} targetPositionOverride - Optional {x, y} position override for target
   * @param {Object} options - Optional calculation options (precomputed lights, senses cache, etc.)
   * @returns {Promise<string>} Visibility state
   */
  async calculateVisibilityBetweenTokens(
    observer,
    target,
    _observerPositionOverride = null,
    targetPositionOverride = null,
    options = undefined,
  ) {
    // Use the new baseline-first workflow
    return await this.#calculateVisibilityWithNewWorkflow(observer, target, _observerPositionOverride, targetPositionOverride, options);
  }
      if (blindnessResult) {
        console.log(`🔥 STEP 1 RETURN: Blindness result - ${blindnessResult}`);
        return blindnessResult;
      }

      // Step 2: Check if target is completely invisible to observer
      console.log('🔥 STEP 2: Checking invisibility condition');
      const invisibilityResult = await this.#checkInvisibilityCondition(observer, target, targetPositionOverride, options);
      if (invisibilityResult) {
        console.log(`🔥 STEP 2 RETURN: Invisibility result - ${invisibilityResult}`);
        return invisibilityResult;
      }

      // Step 3: Check if observer is dazzled (everything appears concealed)
      console.log('🔥 STEP 3: Checking dazzled condition');
      const dazzledResult = this.#checkDazzledCondition(observer, target);
      if (dazzledResult) {
        console.log(`🔥 STEP 3 RETURN: Dazzled result - ${dazzledResult}`);
        return dazzledResult;
      }

      // Step 4: First determine if vision is effective given lighting conditions
      console.log('🔥 STEP 4: Getting observer vision capabilities');
      // Get observer vision capabilities first for sense precedence logic
      const observerVision = this.#getObserverVisionCapabilities(observer, options);
      console.log('🔥 Observer vision capabilities:', observerVision);

      // Check if vision would be effective in current lighting before checking walls
      console.log('🔥 STEP 4: Getting target light level');
      const lightLevel = this.#getTargetLightLevel(target, targetPositionOverride, options);
      console.log('🔥 Target light level:', lightLevel);

      console.log('🔥 STEP 4: Checking if vision is effective');
      const visionEffective = this.#isVisionEffective(observerVision, lightLevel);
      console.log('🔥 Vision effective:', visionEffective);

      // Step 4a: If vision is not effective, check for special darkness rules first
      if (!visionEffective) {
        console.log('🔥 Vision not effective, calling handleIneffectiveVision');
        return await this.#handleIneffectiveVision(observer, target, observerVision, targetPositionOverride, options);
      }

      console.log('🔥 Vision IS effective, proceeding to elevation check');

      // Step 4b: Vision is effective, so check line of sight for walls
      const losResult = this.#handleLineOfSightCheck(observer, target);
      if (losResult) return losResult;

      // Step 4c: Check if target is elevated and observer lacks appropriate senses
      const elevationResult = this.#checkElevationRules(observer, target);
      if (elevationResult) return elevationResult;

      // Step 5: Check lighting conditions at target's position (already calculated above)
      // Get position and options for later calculations
      const targetPosition = targetPositionOverride || {
        x: target.document.x + (target.document.width * canvas.grid.size) / 2,
        y: target.document.y + (target.document.height * canvas.grid.size) / 2,
        elevation: target.document.elevation || 0,
      };

      const opts = options && typeof options === 'object' ? options : {};
      const pre = opts.precomputedLights || null;
      const stats = opts.precomputeStats || null;
      // Use observerVision already calculated in Step 4 for sense precedence
      // if (log.enabled())
      //   log.debug(() => ({
      //     step: 'lighting',
      //     target: target.name,
      //     pos: targetPosition,
      //     lightLevel,
      //   }));
      // if (log.enabled())
      //   log.debug(() => ({ step: 'vision-capabilities', observer: observer.name, observerVision }));

      // Step 5.5: Check for cross-boundary darkness scenarios
      const darknessResult = await this.#handleCrossBoundaryDarkness(observer, target, observerVision, lightLevel, _observerPositionOverride, targetPosition, pre, stats, options);
      if (darknessResult !== null) {
        return darknessResult;
      } // Step 6: Determine visibility based on light level and observer's vision
      let result = this.#visionAnalyzer.determineVisibilityFromLighting(lightLevel, observerVision);

      // Clamp per imprecise-only rule: if observer has no precise senses on target (including vision), but can sense imprecisely, treat as hidden
      try {
        // When caches are present we still defer range checks to analyzer, as they depend on positions
        const preciseNonVisual = this.#visionAnalyzer.hasPreciseNonVisualInRange(observer, target);
        const canImprecise = this.#visionAnalyzer.canSenseImprecisely(observer, target);
        const hasVisionCapability = observerVision?.hasVision !== false;

        // CACHE FIX: Ensure consistent vision capabilities between calls
        // The core issue is that getVisionCapabilities returns different results between calls due to
        // cache timing. We handle this differently for tests vs production.
        let hasLoS = false;
        if (hasVisionCapability) {

          // In production, temporarily override to ensure consistency
          const originalGetVisionCapabilities = this.#visionAnalyzer.getVisionCapabilities;
          const observerId = observer?.document?.id;

          this.#visionAnalyzer.getVisionCapabilities = function (token) {
            if (token?.document?.id === observerId) {
              return observerVision; // Use our already-determined capabilities
            }
            return originalGetVisionCapabilities.call(this, token);
          };

          try {
            hasLoS = this.#visionAnalyzer.hasLineOfSight(observer, target, true);
          } finally {
            // Always restore the original method
            this.#visionAnalyzer.getVisionCapabilities = originalGetVisionCapabilities;
          }
        }
        const hasSight = hasVisionCapability && hasLoS; // vision only works if LoS is clear


        // Only downgrade if BOTH no visual senses AND no precise non-visual senses, but can sense imprecisely
        if (!hasSight && !preciseNonVisual && canImprecise) {
          // If lighting result says observed but only imprecise senses apply (e.g., darkness without darkvision), degrade to hidden
          if (result === 'observed') {
            result = 'hidden';
          }
          if (result === 'concealed') result = 'hidden';
          if (result === 'hidden' || result === 'undetected') {
            // Ensure not worse than hidden if we can sense imprecisely
            result = 'hidden';
          }
        } else if (!hasSight && !preciseNonVisual && !canImprecise) {
          // No senses can detect → undetected
          result = 'undetected';
        }

      } catch { }
      if (log.enabled())
        log.info(() => ({ step: 'result', observer: observer.name, target: target.name, result }));

      return result;
    } catch (error) {
      try {
        console.warn('PF2E Visioner | calcVis: error, default observed', error);
      } catch { }
      return 'observed'; // Default fallback
    }
  }

  /**
   * NEW: Simplified baseline-first visibility calculation workflow
   * This is the correct order: baseline first, then conditions
   */
  async #calculateVisibilityWithNewWorkflow(observer, target, _observerPositionOverride, targetPositionOverride, options) {
    if (!observer?.actor || !target?.actor) {
      return 'observed';
    }

    try {
      // Step 1: Calculate baseline visibility (observed/concealed/hidden)
      // This considers vision, lighting, line of sight, elevation - but NOT conditions
      const baselineState = await this.#calculateBaselineVisibility(observer, target, targetPositionOverride, options);

      // Step 2: Apply conditions that can override baseline visibility
      
      // 2a: Blindness condition (overrides everything)
      const blindnessResult = this.#checkBlindnessCondition(observer, target);
      if (blindnessResult) {
        return blindnessResult; // Blindness typically returns 'hidden'
      }

      // 2b: Apply invisibility condition to baseline state
      const invisibilityResult = await this.#applyInvisibilityCondition(observer, target, baselineState, targetPositionOverride, options);
      
      // 2c: Apply dazzled condition (everything appears concealed)
      if (this.#conditionManager.isDazzled(observer)) {
        // Dazzled makes everything appear concealed, but this doesn't override invisibility
        if (invisibilityResult === 'undetected' || invisibilityResult === 'hidden') {
          return invisibilityResult; // Invisibility takes precedence
        }
        return 'concealed'; // Otherwise, everything is concealed due to dazzling
      }

      return invisibilityResult;
    } catch (error) {
      // Fallback to baseline if something goes wrong
      return await this.#calculateBaselineVisibility(observer, target, targetPositionOverride, options);
    }
  }

  /**
   * Get vision capabilities for a token (public API)
   * @param {Token} token
   * @returns {Object}
   */
  getVisionCapabilities(token) {
    return this.#visionAnalyzer.getVisionCapabilities(token);
  }

  /**
   * Clear caches in all components
   */
  clearCaches() {
    // Note: LightingCalculator doesn't maintain internal caches that need clearing
    // Lighting data is computed on-demand from Foundry's lighting system

    if (this.#visionAnalyzer && typeof this.#visionAnalyzer.clearVisionCache === 'function') {
      this.#visionAnalyzer.clearVisionCache();
    }
  }

  /**
   * Get component instances for direct access if needed
   * @returns {Object}
   */
  getComponents() {
    return {
      lightingCalculator: this.#lightingCalculator,
      visionAnalyzer: this.#visionAnalyzer,
      ConditionManager: this.#conditionManager,
    };
  }

  /**
   * Get status information
   * @returns {Object}
   */
  getStatus() {
    return {
      initialized: !!(this.#lightingCalculator && this.#visionAnalyzer && this.#conditionManager),
      optimized: true,
      throttling: false,
      circuitBreaker: false,
      description: 'Zero-delay visibility calculator - no throttling or circuit breaking',
      components: {
        lightingCalculator: !!this.#lightingCalculator,
        visionAnalyzer: !!this.#visionAnalyzer,
        ConditionManager: !!this.#conditionManager,
      },
    };
  }

  /**
   * Check if we should skip this calculation based on spatial/LOS optimizations
   * @param {Token} observer - Observer token
   * @param {Token} target - Target token
   * @returns {boolean} Whether to skip the calculation
   * @private
   */
  _shouldSkipCalculation(observer, target) {
    try {
      // Use the stored SpatialAnalysisService instance, fallback to global if not available
      let spatialAnalyzer = this.#spatialAnalyzer;
      if (!spatialAnalyzer) {
        spatialAnalyzer = this._getSpatialAnalyzer();
        if (!spatialAnalyzer) {
          return false; // If no system available, proceed with calculation
        }
      }

      // Check if tokens are excluded from AVS calculations
      const observerExcluded = this.#exclusionManager?.isExcludedToken?.(observer);
      const targetExcluded = this.#exclusionManager?.isExcludedToken?.(target);

      if (observerExcluded || targetExcluded) {
        return true;
      }

      // Check spatial distance optimization
      const maxDistance = spatialAnalyzer.getMaxVisibilityDistance?.() || 20;
      const observerPos = this._getTokenPosition(observer);
      const targetPos = this._getTokenPosition(target);

      const dx = observerPos.x - targetPos.x;
      const dy = observerPos.y - targetPos.y;
      const gridSize = canvas.grid?.size || 1;
      const gridDistanceSq = (dx * dx + dy * dy) / (gridSize * gridSize);

      if (gridDistanceSq > (maxDistance * maxDistance)) {
        return true;
      }

      // Check line of sight optimization - BUT respect special sense ranges
      if (spatialAnalyzer.canTokensSeeEachOther) {
        console.log('🔥 _shouldSkipCalculation: Checking canTokensSeeEachOther');

        const canSee = spatialAnalyzer.canTokensSeeEachOther(observer, target);
        console.log(`🔥 _shouldSkipCalculation: canTokensSeeEachOther = ${canSee}`);

        if (!canSee) {
          // No visual line of sight - check if observer has special senses with range
          console.log(`🔥 _shouldSkipCalculation: Getting observer vision capabilities...`);
          const observerVision = this.#getObserverVisionCapabilities(observer);
          console.log(`🔥 _shouldSkipCalculation: observerVision result:`, observerVision);
          // Add observer reference for fallback
          observerVision.observer = observer;
          const specialSenseRange = this._getMaxSpecialSenseRange(observerVision);
          console.log(`🔥 _shouldSkipCalculation: Max special sense range: ${specialSenseRange}`);

          if (specialSenseRange > 0) {
            // Check if target is within special sense range
            const observerPos = this._getTokenPosition(observer);
            const targetPos = this._getTokenPosition(target);
            const dx = observerPos.x - targetPos.x;
            const dy = observerPos.y - targetPos.y;
            const gridSize = canvas.grid?.size || 1;
            const gridDistance = Math.sqrt(dx * dx + dy * dy) / gridSize;

            console.log(`🔥 _shouldSkipCalculation: Distance: ${gridDistance}, Special sense range: ${specialSenseRange}`);

            if (gridDistance <= specialSenseRange) {
              console.log('🔥 _shouldSkipCalculation: Target within special sense range - NOT skipping calculation');
            } else {
              console.log('🔥 _shouldSkipCalculation: Target beyond special sense range - skipping calculation');
              return true;
            }
          } else {
            console.log('🔥 _shouldSkipCalculation: RETURNING TRUE - no LOS and no special senses');
            return true;
          }
        }
      }

      console.log('🔥 _shouldSkipCalculation: All checks passed, returning false');
      return false;
    } catch (error) {
      console.error(
        'PF2E Visioner | VisibilityCalculator: Error in _shouldSkipCalculation:',
        error,
      );
      // If any error occurs, proceed with calculation (conservative approach)
      return false;
    }
  }

  /**
   * Get the maximum range of special senses that work without line of sight
   * @param {Object} observerVision - Vision capabilities object
   * @returns {number} Maximum range in grid units, or 0 if no special senses
   */
  _getMaxSpecialSenseRange(observerVision) {
    console.log(`🔥 _getMaxSpecialSenseRange: ENTRY - Full vision object:`, observerVision);
    console.log(`🔥 _getMaxSpecialSenseRange: Vision object keys:`, Object.keys(observerVision || {}));

    if (!observerVision) {
      console.log(`🔥 _getMaxSpecialSenseRange: No observerVision - returning 0`);
      return 0;
    }

    let maxRange = 0;

    // PART 1: Check detection modes (like feelTremor for tremorsense)
    const detectionModes = observerVision.detectionModes || {};
    console.log(`🔥 _getMaxSpecialSenseRange: detectionModes:`, detectionModes);

    // Check for non-visual detection modes
    const nonVisualDetectionModes = {
      'feelTremor': 'tremorsense',
      'blindsense': 'blindsense',
      'echolocation': 'echolocation',
      'lifesense': 'lifesense'
    };

    for (const [modeName, senseName] of Object.entries(nonVisualDetectionModes)) {
      if (detectionModes[modeName]) {
        const range = detectionModes[modeName].range || 60; // Default to 60 if no range
        console.log(`🔥 _getMaxSpecialSenseRange: Found ${modeName} (${senseName}) with range ${range}`);
        maxRange = Math.max(maxRange, range);
      }
    }

    // Log all properties to find where other senses might be stored
    for (const [key, value] of Object.entries(observerVision)) {
      if (key !== 'observer') { // Skip the observer we added
        console.log(`🔥 _getMaxSpecialSenseRange: ${key}:`, value);
      }
    }

    const sensingSummary = observerVision.sensingSummary || {};
    console.log(`🔥 _getMaxSpecialSenseRange: sensingSummary:`, sensingSummary);

    const allSenses = [...(sensingSummary.imprecise || []), ...(sensingSummary.precise || [])];
    console.log(`🔥 _getMaxSpecialSenseRange: allSenses:`, allSenses);

    // PART 2: Check traditional senses in sensingSummary
    const nonVisualSenseTypes = ['tremorsense', 'blindsense', 'echolocation', 'lifesense'];

    for (const sense of allSenses) {
      console.log(`🔥 _getMaxSpecialSenseRange: Checking traditional sense:`, sense);
      if (nonVisualSenseTypes.includes(sense.type)) {
        const range = sense.range || 0;
        console.log(`🔥 _getMaxSpecialSenseRange: Found traditional ${sense.type} with range ${range}`);
        maxRange = Math.max(maxRange, range);
      }
    }

    console.log(`🔥 _getMaxSpecialSenseRange: Max range from detection modes + senses: ${maxRange}`);

    // FALLBACK: If no senses found in vision object, check observer actor directly
    if (maxRange === 0 && observerVision.observer) {
      console.log(`🔥 _getMaxSpecialSenseRange: Trying fallback - checking observer actor directly`);
      const actor = observerVision.observer?.actor;
      if (actor) {
        const actorSenses = actor.system?.perception?.senses || actor.system?.senses || [];
        console.log(`🔥 _getMaxSpecialSenseRange: Actor senses:`, actorSenses);

        for (const sense of actorSenses) {
          if (sense.type === 'tremorsense') {
            const range = sense.range || sense.value || 60; // Default to 60 if no range specified
            console.log(`🔥 _getMaxSpecialSenseRange: Found tremorsense via fallback with range ${range}`);
            maxRange = Math.max(maxRange, range);
          }
        }
      }
    }

    console.log(`🔥 _getMaxSpecialSenseRange: Final max range: ${maxRange}`);
    return maxRange;
  }  /**
   * Check if observer has non-visual senses that can work without line of sight
   * @param {Object} observerVision - Vision capabilities object
   * @returns {boolean} True if observer has tremorsense, blindsense, or other non-visual senses
   */
  _hasNonVisualSenses(observerVision) {
    return this._getMaxSpecialSenseRange(observerVision) > 0;
  }

  /**
   * Get token position for distance calculations
   * @param {Token} token - Token to get position for
   * @returns {Object} Position {x, y}
   * @private
   */
  _getTokenPosition(token) {
    try {
      return {
        x: token.document.x + (token.document.width * canvas.grid.size) / 2,
        y: token.document.y + (token.document.height * canvas.grid.size) / 2,
      };
    } catch {
      return { x: 0, y: 0 };
    }
  }

  /**
   * Get lighting calculator for debugging
   * @returns {LightingCalculator} The lighting calculator instance
   */
  getLightingCalculator() {
    return this.#lightingCalculator;
  }

  /**
   * Get vision analyzer for debugging
   * @returns {VisionAnalyzer} The vision analyzer instance
   */
  getVisionAnalyzer() {
    return this.#visionAnalyzer;
  }

  /**
   * Get condition manager for debugging
   * @returns {ConditionManager} The condition manager instance
   */
  getConditionManager() {
    return this.#conditionManager;
  }

  /**
   * Manual line-rectangle intersection check
   * @param {Object} rayStart - Ray start point {x, y}
   * @param {Object} rayEnd - Ray end point {x, y}
   * @param {number} left - Rectangle left edge
   * @param {number} top - Rectangle top edge
   * @param {number} right - Rectangle right edge
   * @param {number} bottom - Rectangle bottom edge
   * @returns {boolean} - Whether the line intersects the rectangle
   */
  #lineIntersectsRectangle(rayStart, rayEnd, left, top, right, bottom) {
    // Check if either endpoint is inside the rectangle
    if (
      (rayStart.x >= left && rayStart.x <= right && rayStart.y >= top && rayStart.y <= bottom) ||
      (rayEnd.x >= left && rayEnd.x <= right && rayEnd.y >= top && rayEnd.y <= bottom)
    ) {
      return true;
    }

    // Check intersection with each edge of the rectangle
    const edges = [
      { x1: left, y1: top, x2: right, y2: top }, // top edge
      { x1: right, y1: top, x2: right, y2: bottom }, // right edge
      { x1: right, y1: bottom, x2: left, y2: bottom }, // bottom edge
      { x1: left, y1: bottom, x2: left, y2: top }, // left edge
    ];

    for (const edge of edges) {
      if (this.#lineSegmentsIntersect(rayStart, rayEnd, edge)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Check if two line segments intersect
   * @param {Object} line1Start - First line start point {x, y}
   * @param {Object} line1End - First line end point {x, y}
   * @param {Object} line2 - Second line with {x1, y1, x2, y2}
   * @returns {boolean} - Whether the line segments intersect
   */
  #lineSegmentsIntersect(line1Start, line1End, line2) {
    const x1 = line1Start.x,
      y1 = line1Start.y;
    const x2 = line1End.x,
      y2 = line1End.y;
    const x3 = line2.x1,
      y3 = line2.y1;
    const x4 = line2.x2,
      y4 = line2.y2;

    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (Math.abs(denom) < 1e-10) return false; // Lines are parallel

    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

    return t >= 0 && t <= 1 && u >= 0 && u <= 1;
  }

  /**
   * Helper method to determine if observer can see normally in current conditions
   * Used for invisibility state determination
   * @param {Token} observer - The observing token
   * @param {Token} target - The target token  
   * @param {Object} lightLevel - Light level at target position
   * @param {Object} observerVision - Observer's vision capabilities
   * @returns {boolean} - Whether the observer can see normally
   */
  #canObserverSeeNormally(observer, target, lightLevel, observerVision) {
    try {
      // Check if observer has effective vision in current lighting
      if (!observerVision?.hasVision) {
        return false;
      }

      const darknessRank = lightLevel?.darknessRank ?? 0;

      if (darknessRank === 0) {
        return true; // Normal lighting
      } else if (darknessRank >= 1 && darknessRank <= 3 && observerVision.hasDarkvision) {
        return true; // Darkvision works in rank 1-3 darkness  
      } else if (darknessRank >= 4 && observerVision.hasGreaterDarkvision) {
        return true; // Greater darkvision works in rank 4+ darkness
      }

      return false;
    } catch {
      return false;
    }
  }

  /**
   * Check if a ray intersects with a circle
   * @param {foundry.canvas.geometry.Ray} ray - The ray to check
   * @param {number} centerX - Circle center X coordinate
   * @param {number} centerY - Circle center Y coordinate
   * @param {number} radius - Circle radius
   * @returns {boolean} - Whether the ray intersects the circle
   */
  #rayIntersectsCircle(ray, centerX, centerY, radius) {
    try {
      const rayStart = ray.A;
      const rayEnd = ray.B;


      // Check if either endpoint is inside the circle
      const distStart = Math.sqrt((rayStart.x - centerX) ** 2 + (rayStart.y - centerY) ** 2);
      const distEnd = Math.sqrt((rayEnd.x - centerX) ** 2 + (rayEnd.y - centerY) ** 2);


      if (distStart <= radius || distEnd <= radius) {
        return true;
      }

      // Check if the line segment intersects the circle
      // Calculate closest point on line to circle center
      const dx = rayEnd.x - rayStart.x;
      const dy = rayEnd.y - rayStart.y;
      const lineLengthSquared = dx * dx + dy * dy;

      if (lineLengthSquared === 0) {
        // Ray start and end are the same point
        return distStart <= radius;
      }

      const t = Math.max(
        0,
        Math.min(
          1,
          ((centerX - rayStart.x) * dx + (centerY - rayStart.y) * dy) / lineLengthSquared,
        ),
      );
      const closestX = rayStart.x + t * dx;
      const closestY = rayStart.y + t * dy;

      const distToCenter = Math.sqrt((closestX - centerX) ** 2 + (closestY - centerY) ** 2);


      return distToCenter <= radius;
    } catch (error) {
      console.error('PF2E Visioner | Error checking ray-circle intersection:', {
        error: error.message,
        centerX,
        centerY,
        radius,
        ray: { A: ray.A, B: ray.B },
      });
      return false;
    }
  }

  /**
   * Check if a ray intersects with a FoundryVTT shape (polygon)
   * @param {foundry.canvas.geometry.Ray} ray - The ray to check
   * @param {PIXI.Polygon} shape - The shape to check against
   * @returns {boolean} - Whether the ray intersects the shape
   */
  #rayIntersectsShape(ray, shape) {
    try {
      // Convert ray to line segment points
      const rayStart = ray.A;
      const rayEnd = ray.B;

      // Check if either endpoint is inside the shape
      if (shape.contains(rayStart.x, rayStart.y) || shape.contains(rayEnd.x, rayEnd.y)) {
        return true;
      }

      // Check if ray intersects any edge of the polygon
      const points = shape.points;
      for (let i = 0; i < points.length; i += 2) {
        const j = (i + 2) % points.length;

        const edge = {
          x1: points[i],
          y1: points[i + 1],
          x2: points[j],
          y2: points[j + 1],
        };

        if (this.#lineSegmentsIntersect(rayStart, rayEnd, edge)) {
          return true;
        }
      }

      return false;
    } catch (error) {
      console.error('PF2E Visioner | Error checking ray-shape intersection:', {
        error: error.message,
        hasShape: !!shape,
        hasPoints: !!shape?.points,
        ray: { A: ray.A, B: ray.B },
      });
      return false;
    }
  }

  /**
   * Check if the line between two tokens passes through darkness
   * This is used to detect when tokens are on opposite sides of a darkness effect
   * @param {Token} observer - The observing token
   * @param {Token} target - The target token
   * @returns {boolean} True if the line passes through darkness
   */
  #doesLinePassThroughDarkness(observer, target, observerPosOverride = null, targetPosOverride = null) {
    try {
      const observerPos = observerPosOverride || this._getTokenPosition(observer);
      const targetPos = targetPosOverride || this._getTokenPosition(target);

      // Cast a ray between the tokens to check for darkness effects
      const ray = new foundry.canvas.geometry.Ray(observerPos, targetPos);


      // Get all darkness sources that the ray passes through
      let lightSources = [];
      try {
        // First check canvas.effects.darknessSources (used by LightingCalculator)
        const darknessSources = canvas.effects?.darknessSources || [];
        // Also check canvas.lighting for additional darkness sources
        const lightObjects =
          canvas.lighting?.objects?.children || canvas.lighting?.placeables || [];

        // Combine both sources
        const allSources = [...darknessSources, ...lightObjects];

        lightSources = allSources.filter((light) => {
          // Check for darkness sources - either isDarknessSource property or negative config
          const isDarkness = light.isDarknessSource || light.document?.config?.negative || false;

          // Treat undefined active as true (some darkness sources may not have explicit active property)
          const isActive = light.active !== false;
          const isVisible = light.visible !== false;

          if (!isDarkness || !isActive || !isVisible) {
            return false;
          }

          // Check if the ray intersects with the light source's area
          // For circular darkness sources, use precise circle-line intersection
          let intersects = false;
          try {
            // Get the radius for circular intersection test
            // For darkness sources, use total effective area (bright + dim) to match visual rendering
            // PointDarknessSource has calculated values in data property
            const brightValue = light.data?.bright || light.config?.bright || light.bright || 0;
            const dimValue = light.data?.dim || light.config?.dim || light.dim || 0;
            const totalRadius = brightValue + dimValue;

            // For darkness sources with visual coverage but no bright/dim values, 
            // Use the actual configured radius without artificial expansion
            let radius = totalRadius > 0 ? totalRadius : (light.radius || 0);

            const centerX = light.x;
            const centerY = light.y;

            if (radius > 0) {
              // Use precise circle-line intersection for circular darkness sources
              intersects = this.#rayIntersectsCircle(ray, centerX, centerY, radius);
            } else {
              // Fallback to shape-based intersection for non-circular sources
              if (light.shape) {
                intersects = this.#rayIntersectsShape(ray, light.shape);
              } else {
                // Final fallback to bounds check
                const lightBounds = light.bounds;
                if (!lightBounds) {
                  return false;
                }

                // Try different intersection methods
                if (typeof ray.intersectRectangle === 'function') {
                  intersects = ray.intersectRectangle(lightBounds);
                } else if (typeof ray.intersects === 'function') {
                  intersects = ray.intersects(lightBounds);
                } else {
                  // Manual rectangle intersection check
                  const rayStart = ray.A;
                  const rayEnd = ray.B;

                  // Check if ray intersects rectangle bounds
                  const left = lightBounds.x;
                  const right = lightBounds.x + lightBounds.width;
                  const top = lightBounds.y;
                  const bottom = lightBounds.y + lightBounds.height;

                  // Use line-rectangle intersection algorithm
                  intersects = this.#lineIntersectsRectangle(
                    rayStart,
                    rayEnd,
                    left,
                    top,
                    right,
                    bottom,
                  );
                }
              }
            }
          } catch (error) {
            console.error('PF2E Visioner | Ray intersection failed:', {
              id: light.id,
              error: error.message,
              errorType: error.constructor.name,
              hasRadius: !!(light.radius || light.data?.bright || light.data?.dim),
              ray: { A: ray.A, B: ray.B },
            });
            return false;
          }

          return intersects;
        });
      } catch (error) {
        console.error('PF2E Visioner | Error filtering light sources:', error);
      }

      // Check for darkness effects along the ray
      let passesThroughDarkness = false;
      let darknessEffects = [];

      // Check each darkness source the ray passes through
      for (const lightSource of lightSources) {
        // Find the ambient light document to get the proper rank flag
        let ambientDoc = null;
        let darknessRank = 0;

        // Try to get document directly
        if (lightSource.document) {
          ambientDoc = lightSource.document;
        }
        // Try to find by sourceId
        else if (lightSource.sourceId) {
          try {
            // sourceId format is usually "DocumentType.documentId"
            const [docType, docId] = lightSource.sourceId.split('.');
            if (docType === 'AmbientLight' && docId) {
              ambientDoc = canvas.scene.lights.get(docId);
            }
          } catch (error) {
            // Silently continue if we can't parse the sourceId
          }
        }
        // Try to find by ID
        else if (lightSource.id) {
          ambientDoc = canvas.scene.lights.get(lightSource.id);
        }

        // Get darkness rank from the ambient light document flag
        if (ambientDoc?.getFlag) {
          darknessRank = Number(ambientDoc.getFlag(MODULE_ID, 'darknessRank') || 0) || 0;
        }

        // Fallback to other methods if no flag found
        if (darknessRank === 0 && lightSource.data?.darknessRank) {
          darknessRank = Number(lightSource.data.darknessRank) || 0;
        }

        if (darknessRank === 0 && ambientDoc?.config) {
          const config = ambientDoc.config;
          darknessRank = Number(config.darknessRank || config.spellLevel || 0) || 0;
        }

        // Default to rank 4 for darkness sources if no specific rank is found
        // This matches the expectation that darkness spells are typically rank 4
        if (darknessRank === 0) darknessRank = 4;

        darknessEffects.push({
          light: lightSource,
          darkness: lightSource.data?.darkness || 1,
          darknessRank: darknessRank,
        });
        passesThroughDarkness = true;
      }

      // Return both whether it passes through darkness and the maximum darkness rank
      const maxDarknessRank =
        darknessEffects.length > 0
          ? Math.max(...darknessEffects.map((effect) => effect.darknessRank))
          : 0;

      return {
        passesThroughDarkness,
        maxDarknessRank,
      };
    } catch (error) {
      console.error('PF2E Visioner | Error checking darkness line of sight:', {
        observer: observer.name,
        target: target.name,
        error: error.message,
        stack: error.stack,
      });
      return { passesThroughDarkness: false, maxDarknessRank: 0 };
    }
  }

  /**
   * Check if observer is blinded and handle non-visual senses
   * @param {Token} observer - The observing token
   * @param {Token} target - The target token
   * @returns {string|null} Visibility result if blinded, null if not blinded
   * @private
   */
  #checkBlindnessCondition(observer, target) {
    const isBlinded = this.#conditionManager.isBlinded(observer);
    if (isBlinded) {
      // If blinded, but has precise non-visual sense in range, can still observe
      try {
        if (this.#visionAnalyzer.hasPreciseNonVisualInRange(observer, target)) return 'observed';
        // If any imprecise sense can detect, target is at least hidden rather than undetected
        if (this.#visionAnalyzer.canSenseImprecisely(observer, target)) return 'hidden';
      } catch { }
      return 'hidden';
    }
    return null;
  }

  /**
   * Check if target is invisible and determine appropriate visibility state
   * @param {Token} observer - The observing token
   * Calculate baseline visibility without conditions (observed/concealed/hidden)
   * Based on vision capabilities, lighting, and line of sight
   * @param {Token} observer - The observing token
   * @param {Token} target - The target token
   * @param {Object} targetPositionOverride - Override target position
   * @param {Object} options - Additional options
   * @returns {Promise<string>} Baseline visibility state (observed, concealed, or hidden)
   */
  async #calculateBaselineVisibility(observer, target, targetPositionOverride, options) {
    // Get observer vision capabilities
    const observerVision = this.#getObserverVisionCapabilities(observer, options);

    // Get target light level
    const lightLevel = this.#getTargetLightLevel(target, targetPositionOverride, options);

    // Check if vision is effective in current lighting
    const visionEffective = this.#isVisionEffective(observerVision, lightLevel);

    // If vision is not effective, handle based on darkness/lighting rules
    if (!visionEffective) {
      const ineffectiveResult = await this.#handleIneffectiveVision(observer, target, observerVision, targetPositionOverride, options);
      // handleIneffectiveVision can return various states, but for baseline we only want observed/concealed/hidden
      if (ineffectiveResult === 'undetected') {
        return 'hidden'; // Baseline should be hidden, conditions can escalate to undetected
      }
      return ineffectiveResult || 'hidden';
    }

    // Vision is effective, check line of sight for walls
    const losResult = this.#handleLineOfSightCheck(observer, target);
    if (losResult) {
      return losResult; // This returns the appropriate visibility state based on wall interactions
    }

    // Check for elevation differences that would affect visibility
    const elevationResult = this.#checkElevationRules(observer, target);
    if (elevationResult) {
      return elevationResult;
    }

    // If we reach here, observer can see target normally
    return 'observed';
  }

  /**
   * Apply invisibility condition to a baseline visibility state
   * @param {Token} observer - The observing token
   * @param {Token} target - The target token
   * @param {string} baselineState - The baseline visibility state (observed, concealed, hidden)
   * @param {Object} targetPositionOverride - Optional position override for target
   * @param {Object} options - Calculation options
   * @returns {Promise<string>} Modified visibility state after applying invisibility
   */
  async #applyInvisibilityCondition(observer, target, baselineState, targetPositionOverride, options) {
    const isInvisible = this.#conditionManager.isInvisibleTo(observer, target);
    if (!isInvisible) {
      return baselineState; // No invisibility, return baseline state unchanged
    }

    // Target is invisible, check for special senses that can override invisibility
    try {
      // If observer has precise non-visual sense (e.g., tremorsense, echolocation) in range → observed
      if (this.#visionAnalyzer.hasPreciseNonVisualInRange(observer, target)) {
        return 'observed';
      }
      
      // If any imprecise sense can detect (e.g., hearing), invisible is at least hidden
      if (this.#visionAnalyzer.canSenseImprecisely(observer, target)) {
        return 'hidden';
      }
    } catch { /* ignore sense errors */ }

    // Apply PF2e invisibility rules based on baseline visibility and lighting conditions
    try {
      // Get lighting and vision info for proper invisibility state calculation
      const targetPosition = targetPositionOverride || {
        x: target.document.x + (target.document.width * canvas.grid.size) / 2,
        y: target.document.y + (target.document.height * canvas.grid.size) / 2,
        elevation: target.document.elevation || 0,
      };

      // Get lighting at target position
      const opts = options && typeof options === 'object' ? options : {};
      const pre = opts.precomputedLights || null;
      const targetId = target?.document?.id;
      let tempLightLevel;
      if (pre && targetId && pre[targetId]) {
        tempLightLevel = pre[targetId];
      } else if (pre && targetId && typeof pre.get === 'function' && pre.has(targetId)) {
        tempLightLevel = pre.get(targetId);
      } else {
        tempLightLevel = this.#lightingCalculator.getLightLevelAt(targetPosition, target);
      }

      // Get observer vision capabilities
      let tempObserverVision = null;
      try {
        const capsMap = opts?.sensesCache;
        const oid = observer?.document?.id;
        if (capsMap && oid && (capsMap.get?.(oid) || capsMap[oid])) {
          tempObserverVision = capsMap.get ? capsMap.get(oid) : capsMap[oid];
        }
      } catch { /* ignore */ }
      if (!tempObserverVision) {
        tempObserverVision = this.#visionAnalyzer.getVisionCapabilities(observer);
      }

      // Check if observer can see normally in current conditions
      const canSeeNormally = this.#canObserverSeeNormally(observer, target, tempLightLevel, tempObserverVision);

      // Create a sneak override checker function
      const hasSneakOverride = async (obs, tgt) => {
        try {
          const targetFlags = tgt?.document?.flags?.['pf2e-visioner'] || {};
          const sneakOverrideKey = `sneak-override-from-${obs?.document?.id}`;
          return !!(targetFlags[sneakOverrideKey]?.success);
        } catch {
          return false;
        }
      };

      // Use ConditionManager's invisibility rules to get the proper state
      const invisibilityState = await this.#conditionManager.getInvisibilityState(
        observer,
        target,
        hasSneakOverride,
        canSeeNormally
      );

      return invisibilityState;
    } catch (error) {
      // Fallback: apply standard invisibility transition based on baseline
      // observed → hidden, concealed → hidden, hidden → undetected
      if (baselineState === 'observed' || baselineState === 'concealed') {
        return 'hidden';
      }
      return 'undetected';
    }
  }

  /**
   * @param {Token} target - The target token
   * @param {Object} targetPositionOverride - Optional position override for target
   * @param {Object} options - Calculation options
   * @returns {string|null} Visibility result if invisible, null if not invisible
   * @private
   */
  async #checkInvisibilityCondition(observer, target, targetPositionOverride, options) {
    const isInvisible = this.#conditionManager.isInvisibleTo(observer, target);
    if (isInvisible) {
      // If observer has precise non-visual sense (e.g., tremorsense, echolocation) in range → observed
      try {
        if (this.#visionAnalyzer.hasPreciseNonVisualInRange(observer, target)) return 'observed';
        // If any imprecise sense can detect (e.g., hearing), invisible is at least hidden
        if (this.#visionAnalyzer.canSenseImprecisely(observer, target)) return 'hidden';
      } catch { }

      // Use ConditionManager to determine proper invisibility state based on PF2E rules
      try {
        // We need to compute light level and vision capabilities to determine canSeeNormally
        const targetPosition = targetPositionOverride || {
          x: target.document.x + (target.document.width * canvas.grid.size) / 2,
          y: target.document.y + (target.document.height * canvas.grid.size) / 2,
          elevation: target.document.elevation || 0,
        };

        // Get lighting at target position
        const opts = options && typeof options === 'object' ? options : {};
        const pre = opts.precomputedLights || null;
        const targetId = target?.document?.id;
        let tempLightLevel;
        if (pre && targetId && pre[targetId]) {
          tempLightLevel = pre[targetId];
        } else if (pre && targetId && typeof pre.get === 'function' && pre.has(targetId)) {
          tempLightLevel = pre.get(targetId);
        } else {
          tempLightLevel = this.#lightingCalculator.getLightLevelAt(targetPosition, target);
        }

        // Get observer vision capabilities
        let tempObserverVision = null;
        try {
          const capsMap = opts?.sensesCache;
          const oid = observer?.document?.id;
          if (capsMap && oid && (capsMap.get?.(oid) || capsMap[oid])) {
            tempObserverVision = capsMap.get ? capsMap.get(oid) : capsMap[oid];
          }
        } catch { /* ignore */ }
        if (!tempObserverVision) {
          tempObserverVision = this.#visionAnalyzer.getVisionCapabilities(observer);
        }

        // Check if observer can see normally in current conditions
        const canSeeNormally = this.#canObserverSeeNormally(observer, target, tempLightLevel, tempObserverVision);

        // Create a sneak override checker function
        const hasSneakOverride = async (obs, tgt) => {
          try {
            const targetFlags = tgt?.document?.flags?.['pf2e-visioner'] || {};
            const sneakOverrideKey = `sneak-override-from-${obs?.document?.id}`;
            return !!(targetFlags[sneakOverrideKey]?.success);
          } catch {
            return false;
          }
        };

        const invisibilityState = await this.#conditionManager.getInvisibilityState(
          observer,
          target,
          hasSneakOverride,
          canSeeNormally
        );

        return invisibilityState;
      } catch (error) {
        // Fallback to default invisibility logic if getInvisibilityState fails
        return 'undetected';
      }
    }
    return null;
  }

  /**
   * Check if observer is dazzled and handle non-visual senses
   * @param {Token} observer - The observing token
   * @param {Token} target - The target token
   * @returns {string|null} Visibility result if dazzled, null if not dazzled
   * @private
   */
  #checkDazzledCondition(observer, target) {
    const isDazzled = this.#conditionManager.isDazzled(observer);
    if (isDazzled) {
      // If you have a precise non-visual sense in range, dazzled doesn't matter for that target
      try {
        if (this.#visionAnalyzer.hasPreciseNonVisualInRange(observer, target)) return 'observed';
      } catch { }
      // Otherwise, everything is concealed
      return 'concealed';
    }
    return null;
  }

  /**
   * Get observer vision capabilities with caching support
   * @param {Token} observer - The observing token
   * @param {Object} options - Calculation options
   * @returns {Object} Vision capabilities
   * @private
   */
  #getObserverVisionCapabilities(observer, options) {
    let observerVision = null;
    try {
      const capsMap = options?.sensesCache;
      const oid = observer?.document?.id;
      if (capsMap && oid && (capsMap.get?.(oid) || capsMap[oid])) {
        observerVision = capsMap.get ? capsMap.get(oid) : capsMap[oid];
      }
    } catch { /* ignore */ }
    if (!observerVision) {
      observerVision = this.#visionAnalyzer.getVisionCapabilities(observer);
    }
    return observerVision;
  }

  /**
   * Get light level at target position with caching support
   * @param {Token} target - The target token
   * @param {Object} targetPositionOverride - Optional position override
   * @param {Object} options - Calculation options
   * @returns {Object} Light level information
   * @private
   */
  #getTargetLightLevel(target, targetPositionOverride, options) {
    const targetPosition = targetPositionOverride || {
      x: target.document.x + (target.document.width * canvas.grid.size) / 2,
      y: target.document.y + (target.document.height * canvas.grid.size) / 2,
      elevation: target.document.elevation || 0,
    };

    const opts = options && typeof options === 'object' ? options : {};
    const pre = opts.precomputedLights || null;
    const targetId = target?.document?.id;

    if (pre && targetId && pre[targetId]) {
      return pre[targetId];
    } else if (pre && targetId && typeof pre.get === 'function' && pre.has(targetId)) {
      return pre.get(targetId);
    } else {
      return this.#lightingCalculator.getLightLevelAt(targetPosition, target);
    }
  }

  /**
   * Check if vision is effective given current lighting conditions
   * @param {Object} observerVision - Vision capabilities
   * @param {Object} lightLevel - Light level at target position
   * @returns {boolean} Whether vision is effective
   * @private
   */
  #isVisionEffective(observerVision, lightLevel) {
    try {
      // Check if observer has effective vision in current lighting
      if (observerVision?.hasVision) {
        const darknessRank = lightLevel?.darknessRank ?? 0;

        if (darknessRank === 0) {
          return true; // Normal lighting
        } else if (darknessRank >= 1 && darknessRank <= 3 && observerVision.hasDarkvision) {
          return true; // Darkvision works in rank 1-3 darkness  
        } else if (darknessRank >= 4 && observerVision.hasGreaterDarkvision) {
          return true; // Greater darkvision works in rank 4+ darkness
        }
      }
      return false;
    } catch (e) {
      return observerVision?.hasVision || false;
    }
  }

  /**
   * Handle vision ineffectiveness (darkness rules and non-visual senses)
   * @param {Token} observer - The observing token
   * @param {Token} target - The target token
   * @param {Object} observerVision - Vision capabilities
   * @param {Object} targetPositionOverride - Optional position override
   * @param {Object} options - Calculation options
   * @returns {string} Visibility result
   * @private
   */
  async #handleIneffectiveVision(observer, target, observerVision, targetPositionOverride, options) {
    try {
      // Recalculate lighting at target position for step 4a
      const targetPosition = targetPositionOverride || {
        x: target.document.x + (target.document.width * canvas.grid.size) / 2,
        y: target.document.y + (target.document.height * canvas.grid.size) / 2,
        elevation: target.document.elevation || 0,
      };

      const opts = options && typeof options === 'object' ? options : {};
      const pre = opts.precomputedLights || null;
      const targetId = target?.document?.id;
      let step4aLightLevel;
      if (pre && targetId && pre[targetId]) {
        step4aLightLevel = pre[targetId];
      } else if (pre && targetId && typeof pre.get === 'function' && pre.has(targetId)) {
        step4aLightLevel = pre.get(targetId);
      } else {
        step4aLightLevel = this.#lightingCalculator.getLightLevelAt(targetPosition, target);
      }

      const step4aDarknessRank = step4aLightLevel?.darknessRank ?? 0;

      // Check darkness passage and apply vision rules
      const { linePassesThroughDarkness, rayDarknessRank } = await this.#checkDarknessPassage(
        observer,
        target,
        targetPosition,
        options
      );

      // Determine the effective darkness rank (maximum of target darkness or ray darkness)
      const effectiveDarknessRank = Math.max(step4aDarknessRank, rayDarknessRank);

      // Handle rank 4+ darkness vision rules
      if (effectiveDarknessRank >= 4) {
        if (observerVision?.hasGreaterDarkvision) {
          return 'observed';
        } else if (observerVision?.hasDarkvision) {
          return 'concealed';
        }
        // If no darkvision at all, fall through to non-visual senses check
      }

      // Check non-visual senses
      const hasPreciseNonVisual = this.#visionAnalyzer.hasPreciseNonVisualInRange(observer, target);
      const canSenseImprecisely = this.#visionAnalyzer.canSenseImprecisely(observer, target);

      if (hasPreciseNonVisual) {
        return 'observed';
      }

      if (canSenseImprecisely) {
        return 'hidden';
      }

      return 'undetected';
    } catch {
      return 'hidden';
    }
  }

  /**
   * Check if line passes through darkness and get darkness information
   * @param {Token} observer - The observing token
   * @param {Token} target - The target token
   * @param {Object} targetPosition - Target position
   * @param {Object} options - Calculation options
   * @returns {Object} Darkness passage information
   * @private
   */
  async #checkDarknessPassage(observer, target, targetPosition, options) {
    const observerPosition = {
      x: observer.document.x + (observer.document.width * canvas.grid.size) / 2,
      y: observer.document.y + (observer.document.height * canvas.grid.size) / 2,
      elevation: observer.document.elevation || 0,
    };

    let step4aLinePassesThroughDarkness = false;
    let step4aRayDarknessRank = 0;

    // Check if we have darkness sources to examine
    const opts = options && typeof options === 'object' ? options : {};
    const pre = opts.precomputedLights || null;
    const observerId = observer?.document?.id;
    let observerLightLevel;
    if (pre && observerId && pre[observerId]) {
      observerLightLevel = pre[observerId];
    } else if (pre && observerId && typeof pre.get === 'function' && pre.has(observerId)) {
      observerLightLevel = pre.get(observerId);
    } else {
      observerLightLevel = this.#lightingCalculator.getLightLevelAt(observerPosition, observer);
    }

    const observerInDarkness = (observerLightLevel?.darknessRank ?? 0) >= 1;
    const targetInDarkness = (this.#getTargetLightLevel(target, null, options)?.darknessRank ?? 0) >= 1;
    const hasDarknessSources = !!(options && typeof options === 'object' && options.hasDarknessSources);

    if (hasDarknessSources || observerInDarkness || targetInDarkness) {
      // Check if line passes through darkness using the same logic as cross-boundary detection
      let darknessResult = null;
      try {
        if (this.#lightingRasterService && typeof this.#lightingRasterService.getRayDarknessInfo === 'function') {
          darknessResult = await this.#lightingRasterService.getRayDarknessInfo(
            observer,
            target,
            observerPosition,
            targetPosition
          );
        }
      } catch { /* ignore and fallback */ }

      if (!darknessResult) {
        darknessResult = this.#doesLinePassThroughDarkness(
          observer,
          target,
          observerPosition,
          targetPosition,
        ) || { passesThroughDarkness: false, maxDarknessRank: 0 };
      }

      step4aLinePassesThroughDarkness = !!darknessResult.passesThroughDarkness;
      step4aRayDarknessRank = Number(darknessResult.maxDarknessRank || 0) || 0;
    }

    return {
      linePassesThroughDarkness: step4aLinePassesThroughDarkness,
      rayDarknessRank: step4aRayDarknessRank
    };
  }

  /**
   * Handle line of sight checking with cross-boundary darkness rules
   * @param {Token} observer - The observing token
   * @param {Token} target - The target token
   * @returns {string|null} Visibility result if blocked/affected, null if clear
   * @private
   */
  #handleLineOfSightCheck(observer, target) {
    try {
      const losClear = !!this.#visionAnalyzer.hasLineOfSight(observer, target, true);

      if (!losClear) {
        // Check for cross-boundary darkness even when LoS is blocked
        const observerPos = { x: observer.x, y: observer.y };
        const targetPos = { x: target.x, y: target.y };
        const observerLight = this.#lightingCalculator.getLightLevelAt(observerPos, observer);
        const targetLight = this.#lightingCalculator.getLightLevelAt(targetPos, target);

        const observerInDarkness = (observerLight?.darknessRank ?? 0) >= 4;
        const targetInDarkness = (targetLight?.darknessRank ?? 0) >= 4;

        const hasDarknessSources = canvas.lighting.sources.some(source =>
          source.object &&
          source.object.document &&
          source.object.document.flags &&
          source.object.document.flags.pf2e &&
          source.object.document.flags.pf2e.darknessRank >= 4
        );

        if (hasDarknessSources && (observerInDarkness || targetInDarkness)) {
          // Check ray intersection for cross-boundary darkness
          const rasterResult = this.#lightingRasterService?.linePassesThroughDarkness(observerPos.x, observerPos.y, targetPos.x, targetPos.y) || { passesThroughDarkness: false, maxDarknessRank: 0 };
          let passesThroughDarkness = rasterResult.passesThroughDarkness;
          let maxDarknessRank = rasterResult.maxDarknessRank;

          // Double-check with precise detector if no darkness found
          if (!passesThroughDarkness) {
            const preciseResult = this.linePassesThroughDarkness(observerPos, targetPos);
            passesThroughDarkness = preciseResult.passesThroughDarkness;
            maxDarknessRank = preciseResult.maxDarknessRank;
          }

          // Apply darkvision concealment rules for rank 4+ darkness
          if (passesThroughDarkness && maxDarknessRank >= 4) {
            const hasGreaterDarkvision = this.#visionAnalyzer.hasGreaterDarkvision(observer);
            const hasDarkvision = this.#visionAnalyzer.hasDarkvision(observer);

            if (hasGreaterDarkvision) {
              // Greater darkvision sees normally through rank 4+ darkness
            } else if (hasDarkvision) {
              // Regular darkvision sees concealed through rank 4+ darkness
              return 'concealed';
            }
          }
        }

        // No cross-boundary darkness concealment applies, check non-visual senses
        try {
          const hasPreciseNonVisual = this.#visionAnalyzer.hasPreciseNonVisualInRange(observer, target);
          const canSenseImprecisely = this.#visionAnalyzer.canSenseImprecisely(observer, target);

          if (hasPreciseNonVisual) return 'observed';
          if (canSenseImprecisely) return 'hidden';

          return 'undetected';
        } catch (error) {
          return 'hidden';
        }
      }
    } catch {
      /* best effort: continue */
    }
    return null; // Line of sight is clear, continue with normal processing
  }

  /**
   * Check if target is elevated and observer lacks appropriate senses
   * @param {Token} observer - The observing token
   * @param {Token} target - The target token
   * @returns {string|null} 'undetected' if elevation blocks vision, null otherwise
   * @private
   */
  #checkElevationRules(observer, target) {
    console.log('🔥 #checkElevationRules called!', observer.name, '→', target.name);
    const observerElevation = observer.document?.elevation || 0;
    const targetElevation = target.document?.elevation || 0;

    if (targetElevation > 0 && targetElevation !== observerElevation) {
      // Special check for tremorsense - it cannot detect elevated targets at all
      const sensingSummary = this.#visionAnalyzer.getSensingSummary(observer, observer.actor);

      // Check if observer has tremorsense (in imprecise or precise arrays)
      const hasTremorsense = [...(sensingSummary.imprecise || []), ...(sensingSummary.precise || [])]
        .some(sense => sense.type === 'tremorsense');

      if (hasTremorsense) {
        // If observer has tremorsense, check if they have any viable senses for elevated targets
        const observerVision = this.#visionAnalyzer.getVisionCapabilities(observer);

        // Debug logging
        console.log('🔍 Tremorsense elevation check:', {
          hasTremorsense,
          observerElevation,
          targetElevation,
          observerVision,
          sensingSummary
        });

        const hasViableSensesForElevation =
          observerVision.hasDarkvision ||
          observerVision.hasLowLightVision ||
          observerVision.hasVision ||
          sensingSummary.echolocation ||
          sensingSummary.scent;

        console.log('🔍 Viable senses check:', {
          hasDarkvision: observerVision.hasDarkvision,
          hasLowLightVision: observerVision.hasLowLightVision,
          hasVision: observerVision.hasVision,
          echolocation: sensingSummary.echolocation,
          scent: sensingSummary.scent,
          hasViableSensesForElevation
        });

        if (!hasViableSensesForElevation) {
          console.log('✅ Returning undetected for tremorsense + elevated target');
          return 'undetected';
        } else {
          console.log('❌ Has viable senses, not returning undetected');
        }
      }

      // Check if observer has senses that can detect elevated targets
      const canDetectElevated = this.#visionAnalyzer.canDetectElevatedTarget(observer, target);

      if (!canDetectElevated) {
        return 'undetected';
      }
    }
    return null;
  }

  /**
   * Handle cross-boundary darkness scenarios and darkness ray intersections
   * @param {Token} observer
   * @param {Token} target
   * @param {Object} observerVision
   * @param {Object} lightLevel
   * @param {Object|null} _observerPositionOverride
   * @param {Object} targetPosition
   * @param {Object} pre - Pre-computed lighting cache
   * @param {Object} stats - Statistics tracking object
   * @param {Object} options - Processing options
   * @returns {Promise<string|null>} Visibility state if darkness rules apply, null otherwise
   * @private
   */
  async #handleCrossBoundaryDarkness(observer, target, observerVision, lightLevel, _observerPositionOverride, targetPosition, pre, stats, options) {
    // Get observer position and light level
    const observerPosition = _observerPositionOverride || {
      x: observer.document.x + (observer.document.width * canvas.grid.size) / 2,
      y: observer.document.y + (observer.document.height * canvas.grid.size) / 2,
      elevation: observer.document.elevation || 0,
    };

    const observerLightLevel = this.#getObserverLightLevel(observer, observerPosition, pre, stats);

    const observerInDarkness = (observerLightLevel?.darknessRank ?? 0) >= 1;
    const targetInDarkness = (lightLevel?.darknessRank ?? 0) >= 1;

    // Check for darkness ray intersection
    const { linePassesThroughDarkness, rayDarknessRank } = await this.#checkDarknessRayIntersection(
      observer, target, observerPosition, targetPosition
    );

    // Check for cross-boundary darkness scenarios
    const isCrossBoundary = (observerInDarkness !== targetInDarkness) || linePassesThroughDarkness;

    if (isCrossBoundary) {
      return this.#applyCrossBoundaryDarknessRules(
        observerVision, observerInDarkness, targetInDarkness, linePassesThroughDarkness,
        rayDarknessRank, observerLightLevel, lightLevel
      );
    } else {
      return this.#applySameBoundaryDarknessRules(
        observerVision, observerInDarkness, targetInDarkness, linePassesThroughDarkness,
        rayDarknessRank, observerLightLevel, lightLevel
      );
    }
  }

  /**
   * Get observer light level from cache or calculate
   * @param {Token} observer
   * @param {Object} observerPosition
   * @param {Object} pre - Pre-computed lighting cache
   * @param {Object} stats - Statistics tracking object
   * @returns {Object} Observer light level
   * @private
   */
  #getObserverLightLevel(observer, observerPosition, pre, stats) {
    const observerId = observer?.document?.id;
    let observerLightLevel;

    if (pre && observerId && pre[observerId]) {
      observerLightLevel = pre[observerId];
      try { if (stats) stats.observerUsed = (stats.observerUsed || 0) + 1; } catch { }
    } else if (pre && observerId && typeof pre.get === 'function' && pre.has(observerId)) {
      observerLightLevel = pre.get(observerId);
      try { if (stats) stats.observerUsed = (stats.observerUsed || 0) + 1; } catch { }
    } else {
      observerLightLevel = this.#lightingCalculator.getLightLevelAt(observerPosition, observer);
      try { if (stats) stats.observerMiss = (stats.observerMiss || 0) + 1; } catch { }
    }

    return observerLightLevel;
  }

  /**
   * Check if line passes through darkness and get the maximum darkness rank
   * @param {Token} observer
   * @param {Token} target
   * @param {Object} observerPosition
   * @param {Object} targetPosition
   * @returns {Promise<Object>} Object with linePassesThroughDarkness and rayDarknessRank
   * @private
   */
  async #checkDarknessRayIntersection(observer, target, observerPosition, targetPosition) {
    let linePassesThroughDarkness = false;
    let rayDarknessRank = 0;

    // Prefer raster service for fast approximation
    let darknessResult = null;
    try {
      if (this.#lightingRasterService && typeof this.#lightingRasterService.getRayDarknessInfo === 'function') {
        darknessResult = await this.#lightingRasterService.getRayDarknessInfo(
          observer, target, observerPosition, targetPosition
        );
      }
    } catch { /* ignore and fallback */ }

    if (!darknessResult) {
      // Fallback to precise shape-based detector
      darknessResult = this.#doesLinePassThroughDarkness(
        observer, target, observerPosition, targetPosition,
      ) || { passesThroughDarkness: false, maxDarknessRank: 0 };
    } else if (darknessResult && darknessResult.passesThroughDarkness === false && darknessResult.maxDarknessRank === 0) {
      // Double-check with precise detector if raster found no darkness
      const preciseResult = this.#doesLinePassThroughDarkness(
        observer, target, observerPosition, targetPosition,
      ) || { passesThroughDarkness: false, maxDarknessRank: 0 };

      if (preciseResult.passesThroughDarkness || preciseResult.maxDarknessRank > 0) {
        darknessResult = preciseResult;
      }
    }

    linePassesThroughDarkness = !!darknessResult.passesThroughDarkness;
    rayDarknessRank = Number(darknessResult.maxDarknessRank || 0) || 0;

    // If raster service detected darkness but rank is 0, find actual darkness sources
    if (linePassesThroughDarkness && rayDarknessRank === 0) {
      rayDarknessRank = await this.#findIntersectedDarknessRank(observerPosition, targetPosition);
    }

    return { linePassesThroughDarkness, rayDarknessRank };
  }

  /**
   * Find darkness rank from intersected darkness sources
   * @param {Object} observerPosition
   * @param {Object} targetPosition
   * @returns {Promise<number>} Maximum darkness rank found
   * @private
   */
  async #findIntersectedDarknessRank(observerPosition, targetPosition) {
    const ray = new foundry.canvas.geometry.Ray(observerPosition, targetPosition);

    // Get all darkness sources
    const allSources = this.#getAllDarknessSources();
    const intersectedSources = this.#filterIntersectedDarknessSources(ray, allSources);

    let maxFoundRank = this.#getDarknessRankFromSources(intersectedSources);

    if (maxFoundRank === 0) {
      // Fallback: check all sources for any darkness rank
      const fallbackRank = this.#getFallbackDarknessRank(allSources);
      maxFoundRank = fallbackRank > 0 ? fallbackRank : 3; // Default to rank 3
    }

    return maxFoundRank;
  }

  /**
   * Get all available darkness sources from canvas
   * @returns {Array} Array of darkness sources
   * @private
   */
  #getAllDarknessSources() {
    let allSources = [];
    try {
      const darknessSources = canvas.effects?.darknessSources || [];
      const lightObjects = canvas.lighting?.objects?.children || canvas.lighting?.placeables || [];
      allSources = [...darknessSources, ...lightObjects];
    } catch (error) {
      console.error('DEBUG Error getting light sources:', error);
    }
    return allSources;
  }

  /**
   * Filter darkness sources that intersect with the ray
   * @param {Ray} ray
   * @param {Array} allSources
   * @returns {Array} Filtered intersected sources
   * @private
   */
  #filterIntersectedDarknessSources(ray, allSources) {
    return allSources.filter(light => {
      const isDarkness = light.isDarknessSource || light.document?.config?.negative || false;
      const isActive = light.active !== false;
      const isVisible = light.visible !== false;

      if (!isDarkness || !isActive || !isVisible) {
        return false;
      }

      try {
        const brightValue = light.data?.bright || light.config?.bright || light.bright || 0;
        const dimValue = light.data?.dim || light.config?.dim || light.dim || 0;
        const totalRadius = brightValue + dimValue;
        let radius = totalRadius > 0 ? totalRadius : (light.radius || 0);

        const centerX = light.x;
        const centerY = light.y;

        if (radius > 0) {
          return this.#rayIntersectsCircle(ray, centerX, centerY, radius);
        }
      } catch (error) {
        console.error('DEBUG Error checking ray intersection:', error);
      }

      return false;
    });
  }

  /**
   * Get darkness rank from intersected sources
   * @param {Array} intersectedSources
   * @returns {number} Maximum darkness rank found
   * @private
   */
  #getDarknessRankFromSources(intersectedSources) {
    let maxFoundRank = 0;

    for (const lightSource of intersectedSources) {
      let darknessRank = 0;
      const ambientDoc = this.#findAmbientLightDocument(lightSource);

      if (ambientDoc?.getFlag) {
        darknessRank = Number(ambientDoc.getFlag('pf2e-visioner', 'darknessRank') || 0) || 0;
      }

      // Fallback methods
      if (darknessRank === 0 && lightSource.data?.darknessRank) {
        darknessRank = Number(lightSource.data.darknessRank) || 0;
      }

      if (darknessRank === 0 && ambientDoc?.config) {
        const config = ambientDoc.config;
        darknessRank = Number(config.darknessRank || config.spellLevel || 0) || 0;
      }

      // Default to rank 4 if we can't determine
      if (darknessRank === 0) darknessRank = 4;

      maxFoundRank = Math.max(maxFoundRank, darknessRank);
    }

    return maxFoundRank;
  }

  /**
   * Find ambient light document for a light source
   * @param {Object} lightSource
   * @returns {Object|null} Ambient light document
   * @private
   */
  #findAmbientLightDocument(lightSource) {
    if (lightSource.document) {
      return lightSource.document;
    }

    if (lightSource.sourceId) {
      try {
        const [docType, docId] = lightSource.sourceId.split('.');
        if (docType === 'AmbientLight' && docId) {
          return canvas.scene.lights.get(docId);
        }
      } catch (error) {
        console.error('DEBUG Error parsing sourceId:', lightSource.sourceId, error);
      }
    }

    if (lightSource.id) {
      return canvas.scene.lights.get(lightSource.id);
    }

    return null;
  }

  /**
   * Get fallback darkness rank from all available sources
   * @param {Array} allSources
   * @returns {number} Maximum darkness rank found in fallback
   * @private
   */
  #getFallbackDarknessRank(allSources) {
    let fallbackRank = 0;

    for (const lightSource of allSources) {
      const isDarkness = lightSource.isDarknessSource || lightSource.document?.config?.negative || false;
      if (!isDarkness) continue;

      const ambientDoc = this.#findAmbientLightDocument(lightSource);
      const sourceRank = this.#extractDarknessRankFromDocument(ambientDoc);

      if (sourceRank > 0) {
        fallbackRank = Math.max(fallbackRank, sourceRank);
      }
    }

    return fallbackRank;
  }

  /**
   * Extract darkness rank from ambient document using multiple methods
   * @param {Object|null} ambientDoc
   * @returns {number} Extracted darkness rank
   * @private
   */
  #extractDarknessRankFromDocument(ambientDoc) {
    if (!ambientDoc?.getFlag) return 0;

    // Try multiple flag locations
    const flagValue = ambientDoc.getFlag('pf2e-visioner', 'darknessRank');
    const pf2eFlags = ambientDoc.getFlag('pf2e');

    let sourceRank = 0;
    if (flagValue === '') {
      sourceRank = 3; // Empty string = rank 3 darkness
    } else if (flagValue && !isNaN(Number(flagValue))) {
      sourceRank = Number(flagValue);
    }

    // Check PF2e spell data
    if (sourceRank === 0 && pf2eFlags) {
      if (pf2eFlags.spellLevel || pf2eFlags.heightenLevel) {
        sourceRank = pf2eFlags.spellLevel || pf2eFlags.heightenLevel || 0;
      }
    }

    // Check intensity
    if (sourceRank === 0 && ambientDoc.config?.intensity !== undefined) {
      if (ambientDoc.config.intensity < 0) {
        sourceRank = Math.abs(ambientDoc.config.intensity);
      }
    }

    // Check system data
    if (sourceRank === 0) {
      const docData = ambientDoc.data || ambientDoc;
      const systemData = docData.system;

      if (systemData?.level) sourceRank = systemData.level;
      if (systemData?.spellLevel) sourceRank = systemData.spellLevel;
      if (systemData?.heightenLevel) sourceRank = systemData.heightenLevel;
      if (systemData?.rank) sourceRank = systemData.rank;
      if (systemData?.darknessRank) sourceRank = systemData.darknessRank;

      // Check document properties directly
      if (docData.level) sourceRank = docData.level;
      if (docData.spellLevel) sourceRank = docData.spellLevel;
      if (docData.heightenLevel) sourceRank = docData.heightenLevel;
      if (docData.rank) sourceRank = docData.rank;
    }

    return sourceRank;
  }

  /**
   * Apply cross-boundary darkness rules
   * @param {Object} observerVision
   * @param {boolean} observerInDarkness
   * @param {boolean} targetInDarkness
   * @param {boolean} linePassesThroughDarkness
   * @param {number} rayDarknessRank
   * @param {Object} observerLightLevel
   * @param {Object} lightLevel
   * @returns {string|null} Visibility result or null to continue processing
   * @private
   */
  #applyCrossBoundaryDarknessRules(observerVision, observerInDarkness, targetInDarkness, linePassesThroughDarkness, rayDarknessRank, observerLightLevel, lightLevel) {
    if (observerInDarkness && !targetInDarkness) {
      // Observer inside darkness, target outside
      if (observerVision.hasVision) {
        if (observerVision.hasGreaterDarkvision) {
          return 'observed';
        } else if (observerVision.hasDarkvision) {
          const effectiveDarknessRank = Math.max(
            rayDarknessRank,
            observerLightLevel?.darknessRank ?? 0,
          );
          return effectiveDarknessRank >= 4 ? 'concealed' : 'observed';
        } else {
          return 'hidden';
        }
      }
    } else if (!observerInDarkness && targetInDarkness) {
      // Observer outside darkness, target inside
      if (observerVision.hasVision) {
        if (observerVision.hasGreaterDarkvision) {
          return 'observed';
        } else if (observerVision.hasDarkvision) {
          const effectiveDarknessRank = Math.max(
            rayDarknessRank,
            lightLevel?.darknessRank ?? 0,
          );
          return effectiveDarknessRank >= 4 ? 'concealed' : 'observed';
        } else {
          return 'hidden';
        }
      }
    } else if (linePassesThroughDarkness) {
      // Line passes through darkness but both tokens are in same lighting state
      if (observerVision.hasVision) {
        if (observerVision.hasGreaterDarkvision) {
          return 'observed';
        } else if (observerVision.hasDarkvision) {
          return rayDarknessRank >= 4 ? 'concealed' : 'observed';
        } else {
          return 'hidden';
        }
      }
    }

    return null;
  }

  /**
   * Apply same-boundary darkness rules
   * @param {Object} observerVision
   * @param {boolean} observerInDarkness
   * @param {boolean} targetInDarkness
   * @param {boolean} linePassesThroughDarkness
   * @param {number} rayDarknessRank
   * @param {Object} observerLightLevel
   * @param {Object} lightLevel
   * @returns {string|null} Visibility result or null to continue processing
   * @private
   */
  #applySameBoundaryDarknessRules(observerVision, observerInDarkness, targetInDarkness, linePassesThroughDarkness, rayDarknessRank, observerLightLevel, lightLevel) {
    // Both tokens outside darkness but line passes through darkness
    if (!observerInDarkness && !targetInDarkness && linePassesThroughDarkness) {
      if (observerVision.hasVision) {
        if (observerVision.hasGreaterDarkvision) {
          return 'observed';
        } else if (observerVision.hasDarkvision) {
          return rayDarknessRank >= 4 ? 'concealed' : 'observed';
        } else {
          return 'hidden';
        }
      }
    }

    // Both tokens inside darkness
    if (observerInDarkness && targetInDarkness) {
      if (observerVision.hasVision) {
        const effectiveDarknessRank = Math.max(
          rayDarknessRank,
          lightLevel?.darknessRank ?? 0,
          observerLightLevel?.darknessRank ?? 0,
        );

        if (observerVision.hasGreaterDarkvision) {
          return effectiveDarknessRank >= 4 ? 'concealed' : 'observed';
        } else if (observerVision.hasDarkvision) {
          return effectiveDarknessRank >= 4 ? 'concealed' : 'observed';
        } else {
          return 'hidden';
        }
      } else {
        return 'hidden';
      }
    }

    // If both tokens are outside darkness, use normal lighting calculation
    return null;
  }
}

// Export singleton instance
export const visibilityCalculator = VisibilityCalculator.getInstance();

// Also export with the legacy name for backward compatibility
export const optimizedVisibilityCalculator = visibilityCalculator;
